<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Echo Shift 3D â€” Cinematic Trails</title>
<style>
  body { margin:0; overflow:hidden; background:black; font-family:system-ui; color:white; }
  #ui { position:fixed; top:10px; left:50%; transform:translateX(-50%); display:flex; gap:20px; font-size:14px; z-index:10; }
  #overlay { position:fixed; top:0; left:0; width:100%; height:100%; display:none; justify-content:center; align-items:center; background: rgba(0,0,0,0.85); color:white; flex-direction:column; text-align:center; z-index:20;}
  #overlay h1 { font-size:48px; margin:0 0 20px 0; }
  #overlay p,#overlay div { font-size:22px; margin:5px 0; }
</style>
</head>
<body>
<div id="ui">
  <div id="score">Score: 0</div>
  <div id="status">SAFE</div>
  <div>R = Rewind</div>
</div>
<div id="overlay">
  <h1>GAME OVER</h1>
  <p id="finalScore">Score: 0</p>
  <div id="leaderboard"></div>
  <p>Refresh to retry</p>
</div>

<script type="module">
import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js";

/* ---------- LEADERBOARD ---------- */
const LB_KEY = "echo_shift_leaderboard";
function loadLeaderboard(){ return JSON.parse(localStorage.getItem(LB_KEY)||"[]"); }
function saveScore(score){ let lb=loadLeaderboard(); lb.push(Math.floor(score)); lb.sort((a,b)=>b-a); lb=lb.slice(0,5); localStorage.setItem(LB_KEY,JSON.stringify(lb)); return lb; }

/* ---------- SCENE ---------- */
const scene = new THREE.Scene();
scene.fog = new THREE.Fog(0x000000,20,80);

/* ---------- CAMERA ---------- */
const camera = new THREE.PerspectiveCamera(60,innerWidth/innerHeight,0.1,200);
camera.position.set(0,35,40);
camera.lookAt(0,0,0);
const baseCamPos = camera.position.clone();
let shakeTimer = 0;

/* ---------- RENDERER ---------- */
const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(innerWidth,innerHeight);
renderer.setPixelRatio(devicePixelRatio);
document.body.appendChild(renderer.domElement);

/* ---------- LIGHT ---------- */
scene.add(new THREE.AmbientLight(0x404040));
const light = new THREE.PointLight(0x00ffff,1.2,100);
light.position.set(0,30,20);
scene.add(light);

/* ---------- FLOOR ---------- */
const floorGeo = new THREE.PlaneGeometry(50,50);
const floorMat = new THREE.MeshStandardMaterial({color:0x111111, side:THREE.DoubleSide});
const floor = new THREE.Mesh(floorGeo,floorMat);
floor.rotation.x = -Math.PI/2;
scene.add(floor);

/* ---------- WALLS ---------- */
const wallGeo = new THREE.BoxGeometry(50,5,0.5);
const wallPositions = [
  {x:0,z:25,transparent:true},   // front wall transparent
  {x:0,z:-25},                    // back wall solid
  {x:25,z:0,rotY:Math.PI/2},     // right wall solid
  {x:-25,z:0,rotY:Math.PI/2}     // left wall solid
];
wallPositions.forEach(pos=>{
  const mat = new THREE.MeshStandardMaterial({
    color:0x333333,
    transparent: !!pos.transparent,
    opacity: pos.transparent ? 0.3 : 1
  });
  const wall = new THREE.Mesh(wallGeo, mat);
  wall.position.set(pos.x,2.5,pos.z);
  if(pos.rotY) wall.rotation.y = pos.rotY;
  scene.add(wall);
});

/* ---------- INPUT ---------- */
const keys = {};
addEventListener("keydown",e=>keys[e.key.toLowerCase()]=true);
addEventListener("keyup",e=>keys[e.key.toLowerCase()]=false);

/* ---------- PLAYER ---------- */
const playerGeo = new THREE.SphereGeometry(1,32,32);
const playerMat = new THREE.MeshStandardMaterial({color:0x00ffcc,emissive:0x00ffcc,emissiveIntensity:0.6});
const player = new THREE.Mesh(playerGeo,playerMat);
scene.add(player);

/* ---------- GAME STATE ---------- */
let shards=[];
let echoes=[];
let timeline=[];
let score=0;
let alive=true;
let grace=120;
let tick=0;
const LIMIT=24;

const overlay=document.getElementById("overlay");
const finalScore=document.getElementById("finalScore");
const lbDiv=document.getElementById("leaderboard");

/* ---------- SHARDS ---------- */
function spawnShard(){
  const angle=Math.random()*Math.PI*2;
  const geo=new THREE.SphereGeometry(1.2,16,16);
  const mat=new THREE.MeshStandardMaterial({
    color:0xff6666,
    emissive:0xff0000,
    emissiveIntensity:1.8
  });
  const mesh=new THREE.Mesh(geo,mat);
  mesh.position.set(0,0,0);
  scene.add(mesh);

  // trail for shard
  const trailGeo = new THREE.BufferGeometry();
  const trailMat = new THREE.LineBasicMaterial({color:0xff4444, transparent:true, opacity:0.6});
  const positions = new Float32Array(100*3); // 100 segments
  trailGeo.setAttribute('position', new THREE.BufferAttribute(positions,3));
  const trailLine = new THREE.Line(trailGeo, trailMat);
  scene.add(trailLine);

  shards.push({mesh,vel:new THREE.Vector3(Math.cos(angle),0,Math.sin(angle)).multiplyScalar(0.4), trail:trailLine, trailPositions:[]});
}

/* ---------- REWIND ---------- */
function rewind(){
  if(timeline.length<60) return;
  echoes.push({path:[...timeline],t:0,mesh:createEchoMesh(),pulse:0, trailPositions:[]});
  timeline=[];
  player.position.set(0,0,0);
  grace=120;
  score+=400;
}

function createEchoMesh(){
  const geo=new THREE.SphereGeometry(1,16,16);
  const mat=new THREE.MeshStandardMaterial({color:0x3399ff,transparent:true,opacity:0.35});
  const m=new THREE.Mesh(geo,mat);
  scene.add(m);
  return m;
}

/* ---------- UPDATE ---------- */
function update(){
  if(!alive) return;

  if(keys["r"]){keys["r"]=false; rewind();}

  const speed=0.4;
  if(keys["w"]||keys["arrowup"]) player.position.z-=speed;
  if(keys["s"]||keys["arrowdown"]) player.position.z+=speed;
  if(keys["a"]||keys["arrowleft"]) player.position.x-=speed;
  if(keys["d"]||keys["arrowright"]) player.position.x+=speed;

  // BOUNDARIES
  player.position.x=Math.max(-LIMIT,Math.min(LIMIT,player.position.x));
  player.position.z=Math.max(-LIMIT,Math.min(LIMIT,player.position.z));

  timeline.push(player.position.clone());
  if(timeline.length>600) timeline.shift();

  // SPAWN SHARDS
  const spawnRate = Math.max(5, 30 - Math.floor(score/500));
  if(tick % spawnRate === 0){
    const shardCount = Math.min(3,1 + Math.floor(score/1000));
    for(let i=0;i<shardCount;i++) spawnShard();
  }

  // SHARD MOVEMENT & COLLISION
  shards = shards.filter(s=>{
    const speedFactor = 1 + score/15000;
    s.mesh.position.add(s.vel.clone().multiplyScalar(speedFactor));

    // update shard trail
    s.trailPositions.push(s.mesh.position.clone());
    if(s.trailPositions.length>50) s.trailPositions.shift();
    const posAttr = s.trail.geometry.attributes.position;
    s.trailPositions.forEach((p,i)=>{
      posAttr.setXYZ(i,p.x,p.y,p.z);
    });
    posAttr.needsUpdate = true;

    for(const e of echoes){
      const echoRadius = Math.max(2.5,3.5 - score/1000);
      if(e.t<e.path.length && s.mesh.position.distanceTo(e.path[e.t])<echoRadius){
        shakeTimer = 5;
        e.pulse = 5;
        s.mesh.material.emissiveIntensity = 3;
        setTimeout(()=>{if(s.mesh) s.mesh.material.emissiveIntensity=1.8;},50);
        scene.remove(s.mesh);
        scene.remove(s.trail);
        return false;
      }
    }

    if(grace<=0 && s.mesh.position.distanceTo(player.position)<1.2){
      alive=false;
      showGameOver();
    }
    return true;
  });

  // ECHO MOVEMENT & PULSE + TRAIL
  echoes.forEach(e=>{
    if(e.t<e.path.length) e.mesh.position.copy(e.path[e.t]);
    if(e.pulse>0){
      e.mesh.material.opacity = 0.35 + e.pulse*0.1;
      e.pulse--;
    } else e.mesh.material.opacity = 0.35;

    e.trailPositions.push(e.mesh.position.clone());
    if(e.trailPositions.length>50) e.trailPositions.shift();
    if(!e.trail) {
      const geo = new THREE.BufferGeometry();
      const positions = new Float32Array(50*3);
      geo.setAttribute('position', new THREE.BufferAttribute(positions,3));
      const mat = new THREE.LineBasicMaterial({color:0x3399ff,transparent:true,opacity:0.35});
      e.trail = new THREE.Line(geo,mat);
      scene.add(e.trail);
    }
    e.trailPositions.forEach((p,i)=>{
      e.trail.geometry.attributes.position.setXYZ(i,p.x,p.y,p.z);
    });
    e.trail.geometry.attributes.position.needsUpdate = true;

    e.t++;
  });

  // CAMERA SHAKE
  if(shakeTimer>0){
    camera.position.x = baseCamPos.x + (Math.random()-0.5)*0.5;
    camera.position.z = baseCamPos.z + (Math.random()-0.5)*0.5;
    shakeTimer--;
  } else {
    camera.position.copy(baseCamPos);
  }

  score++;
  document.getElementById("score").textContent="Score: "+score;
  document.getElementById("status").textContent=grace>0?"SAFE":"DANGER";

  grace--;
  tick++;
}

/* ---------- GAME OVER ---------- */
function showGameOver(){
  overlay.style.display="flex";
  finalScore.textContent="Score: "+score;
  const lb=saveScore(score);
  lbDiv.innerHTML="<strong>Leaderboard:</strong><br>"+lb.map((s,i)=>`#${i+1} - ${s}`).join("<br>");
}

/* ---------- ANIMATE ---------- */
function animate(){update(); renderer.render(scene,camera); requestAnimationFrame(animate);}
animate();

/* ---------- RESIZE ---------- */
addEventListener("resize",()=>{
  camera.aspect=innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth,innerHeight);
});
</script>
</body>
</html>
